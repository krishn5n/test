RE TO DFA DIRECT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_STATES 100
#define MAX_SYMBOLS 26
#define MAX_POSITIONS 100
#define MAX_STACK 100

// Structure for position set
typedef struct {
    int pos[MAX_POSITIONS];
    int size;
} PosSet;

// Structure for syntax tree node
typedef struct Node {
    char symbol;
    int nullable;
    PosSet firstpos;
    PosSet lastpos;
    int position;
    struct Node *left;
    struct Node *right;
} Node;

// Structure for followpos table
PosSet followpos[MAX_POSITIONS];

// Structure for DFA state
typedef struct {
    PosSet positions;
    int transitions[MAX_SYMBOLS];
    int is_final;
} DFAState;

DFAState dfa[MAX_STATES];
int num_states = 0;
int position_counter = 1;
char position_symbols[MAX_POSITIONS];

// Function prototypes
Node* createNode(char symbol);
void addToSet(PosSet *set, int pos);
int isInSet(PosSet *set, int pos);
void unionSets(PosSet *result, PosSet *set1, PosSet *set2);
int setsEqual(PosSet *set1, PosSet *set2);
void copySet(PosSet *dest, PosSet *src);
void printSet(PosSet *set);
Node* parseRegex(char *regex);
void augmentRegex(char *regex, char *augmented);
void calculateNullable(Node *node);
void calculateFirstpos(Node *node);
void calculateLastpos(Node *node);
void calculateFollowpos(Node *node);
void buildDFA(Node *root);
void printSyntaxTree(Node *node, int level);
void printFollowposTable();
void printDFA();

// Create a new node
Node* createNode(char symbol) {
    Node *node = (Node*)malloc(sizeof(Node));
    node->symbol = symbol;
    node->nullable = 0;
    node->firstpos.size = 0;
    node->lastpos.size = 0;
    node->position = 0;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// Add position to set
void addToSet(PosSet *set, int pos) {
    if (!isInSet(set, pos) && set->size < MAX_POSITIONS) {
        set->pos[set->size++] = pos;
    }
}

// Check if position is in set
int isInSet(PosSet *set, int pos) {
    for (int i = 0; i < set->size; i++) {
        if (set->pos[i] == pos) return 1;
    }
    return 0;
}

// Union of two sets
void unionSets(PosSet *result, PosSet *set1, PosSet *set2) {
    result->size = 0;
    for (int i = 0; i < set1->size; i++) {
        addToSet(result, set1->pos[i]);
    }
    for (int i = 0; i < set2->size; i++) {
        addToSet(result, set2->pos[i]);
    }
}

// Check if two sets are equal
int setsEqual(PosSet *set1, PosSet *set2) {
    if (set1->size != set2->size) return 0;
    for (int i = 0; i < set1->size; i++) {
        if (!isInSet(set2, set1->pos[i])) return 0;
    }
    return 1;
}

// Copy set
void copySet(PosSet *dest, PosSet *src) {
    dest->size = src->size;
    for (int i = 0; i < src->size; i++) {
        dest->pos[i] = src->pos[i];
    }
}

// Print set
void printSet(PosSet *set) {
    printf("{");
    for (int i = 0; i < set->size; i++) {
        printf("%d", set->pos[i]);
        if (i < set->size - 1) printf(", ");
    }
    printf("}");
}

// Augment regex with concatenation operator and end marker
void augmentRegex(char *regex, char *augmented) {
    int j = 0;
    for (int i = 0; regex[i] != '\0'; i++) {
        augmented[j++] = regex[i];
        
        // Add concatenation operator '.' between operands
        if ((isalnum(regex[i]) || regex[i] == ')' || regex[i] == '*') &&
            (isalnum(regex[i+1]) || regex[i+1] == '(')) {
            augmented[j++] = '.';
        }
    }
    augmented[j++] = '.';
    augmented[j++] = '#'; // End marker
    augmented[j] = '\0';
}

// Parse regex to syntax tree
Node* parseRegex(char *regex) {
    Node *stack[MAX_STACK];
    char op_stack[MAX_STACK];
    int stack_top = -1;
    int op_top = -1;
    
    for (int i = 0; regex[i] != '\0'; i++) {
        char c = regex[i];
        
        if (isalnum(c) || c == '#') {
            Node *node = createNode(c);
            node->position = position_counter;
            position_symbols[position_counter] = c;
            position_counter++;
            stack[++stack_top] = node;
        }
        else if (c == '(') {
            op_stack[++op_top] = c;
        }
        else if (c == ')') {
            while (op_top >= 0 && op_stack[op_top] != '(') {
                char op = op_stack[op_top--];
                Node *node = createNode(op);
                
                if (op == '*') {
                    node->left = stack[stack_top--];
                } else {
                    node->right = stack[stack_top--];
                    node->left = stack[stack_top--];
                }
                stack[++stack_top] = node;
            }
            op_top--; // Remove '('
        }
        else if (c == '*') {
            Node *node = createNode(c);
            node->left = stack[stack_top--];
            stack[++stack_top] = node;
        }
        else if (c == '.' || c == '|') {
            while (op_top >= 0 && op_stack[op_top] != '(' &&
                   ((c == '|' && op_stack[op_top] != '|') || 
                    (c == '.' && op_stack[op_top] == '.'))) {
                char op = op_stack[op_top--];
                Node *node = createNode(op);
                node->right = stack[stack_top--];
                node->left = stack[stack_top--];
                stack[++stack_top] = node;
            }
            op_stack[++op_top] = c;
        }
    }
    
    while (op_top >= 0) {
        char op = op_stack[op_top--];
        Node *node = createNode(op);
        if (op == '*') {
            node->left = stack[stack_top--];
        } else {
            node->right = stack[stack_top--];
            node->left = stack[stack_top--];
        }
        stack[++stack_top] = node;
    }
    
    return stack[0];
}

// Calculate nullable
void calculateNullable(Node *node) {
    if (!node) return;
    
    calculateNullable(node->left);
    calculateNullable(node->right);
    
    if (isalnum(node->symbol) || node->symbol == '#') {
        node->nullable = 0;
    }
    else if (node->symbol == '|') {
        node->nullable = node->left->nullable || node->right->nullable;
    }
    else if (node->symbol == '.') {
        node->nullable = node->left->nullable && node->right->nullable;
    }
    else if (node->symbol == '*') {
        node->nullable = 1;
    }
}

// Calculate firstpos
void calculateFirstpos(Node *node) {
    if (!node) return;
    
    calculateFirstpos(node->left);
    calculateFirstpos(node->right);
    
    if (isalnum(node->symbol) || node->symbol == '#') {
        addToSet(&node->firstpos, node->position);
    }
    else if (node->symbol == '|') {
        unionSets(&node->firstpos, &node->left->firstpos, &node->right->firstpos);
    }
    else if (node->symbol == '.') {
        if (node->left->nullable) {
            unionSets(&node->firstpos, &node->left->firstpos, &node->right->firstpos);
        } else {
            copySet(&node->firstpos, &node->left->firstpos);
        }
    }
    else if (node->symbol == '*') {
        copySet(&node->firstpos, &node->left->firstpos);
    }
}

// Calculate lastpos
void calculateLastpos(Node *node) {
    if (!node) return;
    
    calculateLastpos(node->left);
    calculateLastpos(node->right);
    
    if (isalnum(node->symbol) || node->symbol == '#') {
        addToSet(&node->lastpos, node->position);
    }
    else if (node->symbol == '|') {
        unionSets(&node->lastpos, &node->left->lastpos, &node->right->lastpos);
    }
    else if (node->symbol == '.') {
        if (node->right->nullable) {
            unionSets(&node->lastpos, &node->left->lastpos, &node->right->lastpos);
        } else {
            copySet(&node->lastpos, &node->right->lastpos);
        }
    }
    else if (node->symbol == '*') {
        copySet(&node->lastpos, &node->left->lastpos);
    }
}

// Calculate followpos
void calculateFollowpos(Node *node) {
    if (!node) return;
    
    if (node->symbol == '.') {
        for (int i = 0; i < node->left->lastpos.size; i++) {
            int pos = node->left->lastpos.pos[i];
            unionSets(&followpos[pos], &followpos[pos], &node->right->firstpos);
        }
    }
    else if (node->symbol == '*') {
        for (int i = 0; i < node->lastpos.size; i++) {
            int pos = node->lastpos.pos[i];
            unionSets(&followpos[pos], &followpos[pos], &node->firstpos);
        }
    }
    
    calculateFollowpos(node->left);
    calculateFollowpos(node->right);
}

// Build DFA from syntax tree
void buildDFA(Node *root) {
    PosSet unmarked[MAX_STATES];
    int unmarked_count = 0;
    
    // Initialize followpos
    for (int i = 0; i < MAX_POSITIONS; i++) {
        followpos[i].size = 0;
    }
    
    // Calculate followpos
    calculateFollowpos(root);
    
    // Start state is firstpos of root
    copySet(&dfa[0].positions, &root->firstpos);
    copySet(&unmarked[unmarked_count++], &root->firstpos);
    num_states = 1;
    
    // Initialize transitions
    for (int i = 0; i < MAX_STATES; i++) {
        for (int j = 0; j < MAX_SYMBOLS; j++) {
            dfa[i].transitions[j] = -1;
        }
        dfa[i].is_final = 0;
    }
    
    // Process unmarked states
    while (unmarked_count > 0) {
        PosSet current = unmarked[--unmarked_count];
        int current_state = -1;
        
        // Find current state index
        for (int i = 0; i < num_states; i++) {
            if (setsEqual(&dfa[i].positions, &current)) {
                current_state = i;
                break;
            }
        }
        
        // Check if final state (contains position of #)
        for (int i = 0; i < current.size; i++) {
            if (position_symbols[current.pos[i]] == '#') {
                dfa[current_state].is_final = 1;
                break;
            }
        }
        
        // For each input symbol
        for (char a = 'a'; a <= 'z'; a++) {
            PosSet next;
            next.size = 0;
            
            // Find all positions with symbol a
            for (int i = 0; i < current.size; i++) {
                int pos = current.pos[i];
                if (position_symbols[pos] == a) {
                    unionSets(&next, &next, &followpos[pos]);
                }
            }
            
            if (next.size > 0) {
                // Check if state already exists
                int next_state = -1;
                for (int i = 0; i < num_states; i++) {
                    if (setsEqual(&dfa[i].positions, &next)) {
                        next_state = i;
                        break;
                    }
                }
                
                // Create new state if doesn't exist
                if (next_state == -1) {
                    next_state = num_states++;
                    copySet(&dfa[next_state].positions, &next);
                    copySet(&unmarked[unmarked_count++], &next);
                }
                
                dfa[current_state].transitions[a - 'a'] = next_state;
            }
        }
    }
}

// Print syntax tree
void printSyntaxTree(Node *node, int level) {
    if (!node) return;
    
    for (int i = 0; i < level; i++) printf("  ");
    printf("Node: %c", node->symbol);
    if (node->position > 0) printf(" (pos: %d)", node->position);
    printf(", nullable: %d, firstpos: ", node->nullable);
    printSet(&node->firstpos);
    printf(", lastpos: ");
    printSet(&node->lastpos);
    printf("\n");
    
    printSyntaxTree(node->left, level + 1);
    printSyntaxTree(node->right, level + 1);
}

// Print followpos table
void printFollowposTable() {
    printf("\nFollowpos Table:\n");
    printf("Position\tSymbol\tFollowpos\n");
    printf("--------\t------\t---------\n");
    for (int i = 1; i < position_counter; i++) {
        printf("%d\t\t%c\t", i, position_symbols[i]);
        printSet(&followpos[i]);
        printf("\n");
    }
}

// Print DFA
void printDFA() {
    printf("\nDFA States:\n");
    for (int i = 0; i < num_states; i++) {
        printf("State %d: ", i);
        printSet(&dfa[i].positions);
        if (dfa[i].is_final) printf(" [FINAL]");
        printf("\n");
        
        printf("  Transitions:\n");
        for (int j = 0; j < MAX_SYMBOLS; j++) {
            if (dfa[i].transitions[j] != -1) {
                printf("    %c -> State %d\n", 'a' + j, dfa[i].transitions[j]);
            }
        }
    }
}

int main() {
    char regex[100], augmented[200];
    
    printf("Enter regular expression (use * for Kleene star, | for OR, () for grouping):\n");
    printf("Example: (a|b)*abb\n");
    scanf("%s", regex);
    
    // Augment regex
    augmentRegex(regex, augmented);
    printf("\nAugmented regex: %s\n", augmented);
    
    // Parse to syntax tree
    Node *root = parseRegex(augmented);
    
    // Calculate nullable, firstpos, lastpos
    calculateNullable(root);
    calculateFirstpos(root);
    calculateLastpos(root);
    
    printf("\n=== Syntax Tree ===\n");
    printSyntaxTree(root, 0);
    
    // Build DFA
    buildDFA(root);
    
    printFollowposTable();
    printDFA();
    
    return 0;
}


LEX - BASIC

%{
#include <stdio.h>
%}

%%
^a*b*a$      { printf("Valid string: %s\n", yytext); }
.|\n         { printf("Invalid string: %s\n", yytext); }
%%

int main()
{
    printf("Enter a string: ");
    yylex();
    return 0;
}

int yywrap()
{
    return 1;
}



RUN CODE : FLEX FILENAME.L -> gcc lex.yy.c -> ./a.out



LEX - READING FILE

%{
#include <stdio.h>
#include <string.h>

int isKeyword(char *word);

%}

%%
"#".*                              { printf("Preprocessor Directive\t%s\n", yytext); }
\"([^\\\"]|\\.)*\"                 { printf("String Literal\t\t%s\n", yytext); }
[0-9]+                             { printf("Constant\t\t\t%s\n", yytext); }
"=="|"!="|"<="|">="|"="|"*"|"%"    { printf("Operator\t\t\t%s\n", yytext); }
"(" | ")" | "{" | "}" | ";" | "," | "#" | "<" | ">" 
                                   { printf("Symbol/Separator\t\t%s\n", yytext); }
[a-zA-Z_][a-zA-Z0-9_]*             {
                                      if(isKeyword(yytext))
                                          printf("Keyword\t\t\t%s\n", yytext);
                                      else
                                          printf("Identifier\t\t%s\n", yytext);
                                   }
[ \t\n]+                           { /* ignore whitespace */ }
.                                  { /* ignore unknown characters */ }
%%

int isKeyword(char *word)
{
    char *keywords[] = {"int","if","else","for","return","break","scanf","printf","while","do","float","char","double","void"};
    int n = sizeof(keywords)/sizeof(keywords[0]);
    for(int i=0; i<n; i++)
        if(strcmp(word, keywords[i]) == 0)
            return 1;
    return 0;
}

int main(int argc, char *argv[])
{
    if(argc < 2) {
        printf("Usage: %s <input_file>\n", argv[0]);
        return 1;
    }

    FILE *fp = fopen(argv[1], "r");
    if(!fp) {
        printf("Cannot open file: %s\n", argv[1]);
        return 1;
    }

    yyin = fp;
    yylex();
    fclose(fp);
    return 0;
}

int yywrap() { return 1; }

RE TO NFA -> FIND NFA FIRST BY YOURSELF AND THEN USE THIS CODE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATES 10
#define MAX_TRANS 10

typedef struct {
    char symbol;
    int to[MAX_TRANS];
    int to_count;
} Transition;

typedef struct {
    int id;
    Transition transitions[MAX_TRANS];
    int trans_count;
    int epsilon[MAX_TRANS];
    int eps_count;
} State;

typedef struct {
    State states[MAX_STATES];
    int start;
    int final;
    int num_states;
} ENFA;

void init_enfa(ENFA* e) {
    e->num_states = 8;
    e->start = 0;
    e->final = 7;
    for (int i = 0; i < e->num_states; i++) {
        e->states[i].id = i;
        e->states[i].trans_count = 0;
        e->states[i].eps_count = 0;
    }
}

void add_transition(ENFA* e, int from, char symbol, int to) {
    State* s = &e->states[from];
    s->transitions[s->trans_count].symbol = symbol;
    s->transitions[s->trans_count].to[s->transitions[s->trans_count].to_count++] = to;
    s->trans_count++;
}

void add_epsilon(ENFA* e, int from, int to) {
    State* s = &e->states[from];
    s->epsilon[s->eps_count++] = to;
}

int contains(int* arr, int count, int val) {
    for (int i = 0; i < count; i++)
        if (arr[i] == val) return 1;
    return 0;
}

void epsilon_closure(ENFA* e, int* current, int* count) {
    int queue[MAX_STATES], front = 0, rear = 0;
    for (int i = 0; i < *count; i++)
        queue[rear++] = current[i];

    while (front < rear) {
        int s = queue[front++];
        State* st = &e->states[s];
        for (int i = 0; i < st->eps_count; i++) {
            int next = st->epsilon[i];
            if (!contains(current, *count, next)) {
                current[(*count)++] = next;
                queue[rear++] = next;
            }
        }
    }
}

int accepts(ENFA* e, const char* input) {
    int current[MAX_STATES], next[MAX_STATES];
    int curr_count = 1, next_count = 0;
    current[0] = e->start;

    epsilon_closure(e, current, &curr_count);

    for (int i = 0; i < strlen(input); i++) {
        char c = input[i];
        next_count = 0;

        for (int j = 0; j < curr_count; j++) {
            State* s = &e->states[current[j]];
            for (int t = 0; t < s->trans_count; t++) {
                if (s->transitions[t].symbol == c) {
                    for (int k = 0; k < s->transitions[t].to_count; k++) {
                        int dest = s->transitions[t].to[k];
                        if (!contains(next, next_count, dest))
                            next[next_count++] = dest;
                    }
                }
            }
        }
        memcpy(current, next, next_count * sizeof(int));
        curr_count = next_count;
        epsilon_closure(e, current, &curr_count);
    }

    return contains(current, curr_count, e->final);
}

void print_enfa(ENFA* e) {
    for (int i = 0; i < e->num_states; i++) {
        State* s = &e->states[i];
        for (int j = 0; j < s->trans_count; j++) {
            for (int k = 0; k < s->transitions[j].to_count; k++) {
                printf("(%d, %c) -> %d\n", i, s->transitions[j].symbol, s->transitions[j].to[k]);
            }
        }
        for (int j = 0; j < s->eps_count; j++) {
            printf("(%d, ε) -> %d\n", i, s->epsilon[j]);
        }
    }
}

void build_enfa(ENFA* e) {
    init_enfa(e);
    add_epsilon(e, 0, 1);
    add_epsilon(e, 7, 1);
    add_epsilon(e, 1, 2);
    add_epsilon(e, 2, 3);
    add_transition(e, 3, '0', 4);
    add_transition(e, 4, '0', 4);
    add_epsilon(e, 4, 5);
    add_epsilon(e, 5, 2);
    add_epsilon(e, 2, 6);
    add_transition(e, 6, '1', 7);
}

int main() {
    ENFA e;
    build_enfa(&e);
    print_enfa(&e);

    char input[100];
    printf("Enter string to check: ");
    scanf("%s", input);

    if (accepts(&e, input))
        printf("Accepted\n");
    else
        printf("Rejected\n");

    return 0;
}

INFIX TO POSTFIX

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

// Stack for operators
char stack[MAX];
int top = -1;

// Push an element onto the stack
void push(char c) {
    if (top == MAX - 1) {
        printf("Stack Overflow\n");
        return;
    }
    stack[++top] = c;
}

// Pop an element from the stack
char pop() {
    if (top == -1)
        return '\0';
    return stack[top--];
}

// Peek top of stack
char peek() {
    if (top == -1)
        return '\0';
    return stack[top];
}

// Define precedence for regex operators
int precedence(char c) {
    switch (c) {
        case '*':
        case '+':
        case '?':
            return 3; // highest precedence
        case '.':   // explicit concatenation
            return 2;
        case '|':
            return 1;
        default:
            return 0;
    }
}

// Function to check if character is operator
int isOperator(char c) {
    return (c == '*' || c == '|' || c == '.' || c == '+' || c == '?');
}

// Function to insert explicit concatenation ('.') where needed
void addConcat(char *re, char *output) {
    int len = strlen(re);
    int j = 0;
    for (int i = 0; i < len; i++) {
        char c1 = re[i];
        char c2 = re[i + 1];
        output[j++] = c1;

        if (c1 != '(' && c2 != ')' && c2 != '|' && !isOperator(c2)) {
            if (!isOperator(c1))
                output[j++] = '.';
        }
    }
    output[j] = '\0';
}

// Convert infix regex to postfix
void infixToPostfix(char *re, char *postfix) {
    char temp[MAX];
    addConcat(re, temp); // add explicit concatenation
    int k = 0;
    for (int i = 0; i < strlen(temp); i++) {
        char c = temp[i];
        if (c == '(') {
            push(c);
        } else if (c == ')') {
            while (peek() != '(')
                postfix[k++] = pop();
            pop(); // remove '('
        } else if (isOperator(c)) {
            while (top != -1 && precedence(peek()) >= precedence(c))
                postfix[k++] = pop();
            push(c);
        } else {
            postfix[k++] = c;
        }
    }
    while (top != -1)
        postfix[k++] = pop();
    postfix[k] = '\0';
}

int main() {
    char regex[MAX], postfix[MAX];

    printf("Enter Regular Expression (e.g. (a|b)*abb): ");
    scanf("%s", regex);

    infixToPostfix(regex, postfix);

    printf("Postfix Expression: %s\n", postfix);

    return 0;
}
SYMBOL TABLE - MATRIX MULT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SYMBOLS 10

typedef struct {
    char name[10];       // Matrix name (e.g., "A")
    char type[10];       // "matrix"
    char datatype[10];   // "int"
    int rows;
    int cols;
    int *address;        // Pointer to dynamically allocated matrix data
} Symbol;

Symbol symbolTable[MAX_SYMBOLS];
int symbolCount = 0;

// Insert symbol into symbol table
void insertSymbol(const char *name, const char *type, const char *datatype,
                  int rows, int cols, int *address) {
    if (symbolCount >= MAX_SYMBOLS) {
        printf("Symbol table full!\n");
        return;
    }
    strcpy(symbolTable[symbolCount].name, name);
    strcpy(symbolTable[symbolCount].type, type);
    strcpy(symbolTable[symbolCount].datatype, datatype);
    symbolTable[symbolCount].rows = rows;
    symbolTable[symbolCount].cols = cols;
    symbolTable[symbolCount].address = address;
    symbolCount++;
}

// Print symbol table
void printSymbolTable() {
    printf("\nSymbol Table:\n");
    printf("%-8s %-8s %-8s %-6s %-6s %s\n", "Name", "Type", "DataType", "Rows", "Cols", "Address");

    for (int i = 0; i < symbolCount; i++) {
        printf("%-8s %-8s %-8s %-6d %-6d %p\n",
               symbolTable[i].name,
               symbolTable[i].type,
               symbolTable[i].datatype,
               symbolTable[i].rows,
               symbolTable[i].cols,
               (void *)symbolTable[i].address);
    }
}

// Utility function to print a matrix
void printMatrix(const char *name, int *matrix, int rows, int cols) {
    printf("%s (%dx%d):\n", name, rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d\t", matrix[i * cols + j]);
        }
        printf("\n");
    }
}

int main() {
    int r1, c1, r2, c2;

    printf("Enter number of rows for First Matrix (A): ");
    scanf("%d", &r1);
    printf("Enter number of columns for First Matrix (A): ");
    scanf("%d", &c1);
    printf("Enter number of rows for Second Matrix (B): ");
    scanf("%d", &r2);
    printf("Enter number of columns for Second Matrix (B): ");
    scanf("%d", &c2);

    if (c1 != r2) {
        printf("Matrix multiplication not possible (columns of A != rows of B).\n");
        return 1;
    }

    // Dynamically allocate memory for matrices as 1D arrays
    int *A = (int *)malloc(r1 * c1 * sizeof(int));
    int *B = (int *)malloc(r2 * c2 * sizeof(int));
    int *C = (int *)malloc(r1 * c2 * sizeof(int));

    if (!A || !B || !C) {
        printf("Memory allocation failed.\n");
        return 1;
    }

    // Input matrices
    printf("Enter elements of First Matrix (A):\n");
    for (int i = 0; i < r1 * c1; i++) {
        scanf("%d", &A[i]);
    }

    printf("Enter elements of Second Matrix (B):\n");
    for (int i = 0; i < r2 * c2; i++) {
        scanf("%d", &B[i]);
    }

    // Initialize result matrix to zero
    for (int i = 0; i < r1 * c2; i++) {
        C[i] = 0;
    }

    // Perform multiplication
    for (int i = 0; i < r1; i++) {
        for (int j = 0; j < c2; j++) {
            for (int k = 0; k < c1; k++) {
                C[i * c2 + j] += A[i * c1 + k] * B[k * c2 + j];
            }
        }
    }

    // Insert matrices into symbol table
    insertSymbol("A", "matrix", "int", r1, c1, A);
    insertSymbol("B", "matrix", "int", r2, c2, B);
    insertSymbol("C", "matrix", "int", r1, c2, C);

    // Print matrices
    printMatrix("Matrix A", A, r1, c1);
    printMatrix("Matrix B", B, r2, c2);
    printMatrix("Matrix C (Result)", C, r1, c2);

    // Print symbol table
    printSymbolTable();

    // Clean up memory
    free(A);
    free(B);
    free(C);

    return 0;
}


PREDICTIVE PARSING


#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>


#define MAX_PROD 50
#define MAX_SYMBOLS 20
#define MAX_LEN 50


typedef struct {
    char lhs;
    char rhs[MAX_LEN];
} Production;


Production grammar[MAX_PROD];
int prodCount = 0;


char nonTerminals[MAX_SYMBOLS];
char terminals[MAX_SYMBOLS];
int ntCount = 0, tCount = 0;


char first[MAX_SYMBOLS][MAX_SYMBOLS];
char follow[MAX_SYMBOLS][MAX_SYMBOLS];
int firstCount[MAX_SYMBOLS];
int followCount[MAX_SYMBOLS];


char parsingTable[MAX_SYMBOLS][MAX_SYMBOLS][MAX_LEN];


// Function prototypes
void inputGrammar();
void removeLeftRecursion();
void extractSymbols();
void computeFirst();
void computeFollow();
void constructParsingTable();
void printGrammar();
void printFirst();
void printFollow();
void printParsingTable();
bool isNonTerminal(char c);
bool isTerminal(char c);
int getNTIndex(char c);
int getTIndex(char c);
void addToSet(char set[], int *count, char c);
bool isInSet(char set[], int count, char c);


int main() {
    printf("=== LL(1) Parser Generator ===\n\n");
    
    inputGrammar();
    printf("\n--- Original Grammar ---\n");
    printGrammar();
    
    removeLeftRecursion();
    printf("\n--- Grammar after Left Recursion Removal ---\n");
    printGrammar();
    
    extractSymbols();
    
    computeFirst();
    printf("\n--- FIRST Sets ---\n");
    printFirst();
    
    computeFollow();
    printf("\n--- FOLLOW Sets ---\n");
    printFollow();
    
    constructParsingTable();
    printf("\n--- LL(1) Parsing Table ---\n");
    printParsingTable();
    
    return 0;
}


void inputGrammar() {
    printf("Enter number of productions: ");
    scanf("%d", &prodCount);
    getchar();
    
    printf("Enter productions (format: A=BC or A=a or A=@ for epsilon):\n");
    for (int i = 0; i < prodCount; i++) {
        char input[MAX_LEN];
        printf("Production %d: ", i + 1);
        fgets(input, MAX_LEN, stdin);
        input[strcspn(input, "\n")] = 0;
        
        char *eq = strchr(input, '=');
        if (eq) {
            grammar[i].lhs = input[0];
            strcpy(grammar[i].rhs, eq + 1);
        }
    }
}


void removeLeftRecursion() {
    Production newGrammar[MAX_PROD];
    int newCount = 0;
    
    for (int i = 0; i < prodCount; ) {
        char lhs = grammar[i].lhs;
        char alpha[MAX_PROD][MAX_LEN]; // Left recursive parts
        char beta[MAX_PROD][MAX_LEN];  // Non-left recursive parts
        int alphaCount = 0, betaCount = 0;
        
        // Collect all productions with same LHS
        int j = i;
        bool hasLeftRecursion = false;
        
        while (j < prodCount && grammar[j].lhs == lhs) {
            if (grammar[j].rhs[0] == lhs) {
                // Left recursive: A -> Aα
                strcpy(alpha[alphaCount++], grammar[j].rhs + 1);
                hasLeftRecursion = true;
            } else {
                // Not left recursive: A -> β
                strcpy(beta[betaCount++], grammar[j].rhs);
            }
            j++;
        }
        
        if (hasLeftRecursion) {
            // Create new non-terminal A'
            char newNT = lhs + '\'';
            
            // A -> βA' for each β
            for (int k = 0; k < betaCount; k++) {
                newGrammar[newCount].lhs = lhs;
                sprintf(newGrammar[newCount].rhs, "%s%c", beta[k], newNT);
                newCount++;
            }
            
            // If no β exists, add A -> A'
            if (betaCount == 0) {
                newGrammar[newCount].lhs = lhs;
                sprintf(newGrammar[newCount].rhs, "%c", newNT);
                newCount++;
            }
            
            // A' -> αA' for each α
            for (int k = 0; k < alphaCount; k++) {
                newGrammar[newCount].lhs = newNT;
                sprintf(newGrammar[newCount].rhs, "%s%c", alpha[k], newNT);
                newCount++;
            }
            
            // A' -> ε
            newGrammar[newCount].lhs = newNT;
            strcpy(newGrammar[newCount].rhs, "@");
            newCount++;
        } else {
            // No left recursion, copy as is
            for (int k = i; k < j; k++) {
                newGrammar[newCount++] = grammar[k];
            }
        }
        
        i = j;
    }
    
    // Copy back to original grammar
    for (int i = 0; i < newCount; i++) {
        grammar[i] = newGrammar[i];
    }
    prodCount = newCount;
}


void extractSymbols() {
    ntCount = tCount = 0;
    
    for (int i = 0; i < prodCount; i++) {
        if (!isInSet(nonTerminals, ntCount, grammar[i].lhs)) {
            nonTerminals[ntCount++] = grammar[i].lhs;
        }
        
        for (int j = 0; grammar[i].rhs[j]; j++) {
            char c = grammar[i].rhs[j];
            if (isupper(c) && !isInSet(nonTerminals, ntCount, c)) {
                nonTerminals[ntCount++] = c;
            } else if ((islower(c) || c == '+' || c == '*' || c == '(' || c == ')') 
                       && c != '@' && !isInSet(terminals, tCount, c)) {
                terminals[tCount++] = c;
            }
        }
    }
    
    // Add $ to terminals
    if (!isInSet(terminals, tCount, '$')) {
        terminals[tCount++] = '$';
    }
}


void computeFirst() {
    for (int i = 0; i < ntCount; i++) {
        firstCount[i] = 0;
    }
    
    bool changed = true;
    while (changed) {
        changed = false;
        
        for (int i = 0; i < prodCount; i++) {
            char lhs = grammar[i].lhs;
            char *rhs = grammar[i].rhs;
            int idx = getNTIndex(lhs);
            
            if (rhs[0] == '@') {
                // ε production
                if (!isInSet(first[idx], firstCount[idx], '@')) {
                    addToSet(first[idx], &firstCount[idx], '@');
                    changed = true;
                }
            } else if (isTerminal(rhs[0])) {
                // First symbol is terminal
                if (!isInSet(first[idx], firstCount[idx], rhs[0])) {
                    addToSet(first[idx], &firstCount[idx], rhs[0]);
                    changed = true;
                }
            } else {
                // First symbol is non-terminal
                int k = 0;
                bool allHaveEpsilon = true;
                
                while (rhs[k] && isNonTerminal(rhs[k])) {
                    int rhsIdx = getNTIndex(rhs[k]);
                    bool hasEpsilon = false;
                    
                    for (int j = 0; j < firstCount[rhsIdx]; j++) {
                        if (first[rhsIdx][j] == '@') {
                            hasEpsilon = true;
                        } else {
                            if (!isInSet(first[idx], firstCount[idx], first[rhsIdx][j])) {
                                addToSet(first[idx], &firstCount[idx], first[rhsIdx][j]);
                                changed = true;
                            }
                        }
                    }
                    
                    if (!hasEpsilon) {
                        allHaveEpsilon = false;
                        break;
                    }
                    k++;
                }
                
                if (allHaveEpsilon) {
                    if (rhs[k] == '\0') {
                        if (!isInSet(first[idx], firstCount[idx], '@')) {
                            addToSet(first[idx], &firstCount[idx], '@');
                            changed = true;
                        }
                    } else if (isTerminal(rhs[k])) {
                        if (!isInSet(first[idx], firstCount[idx], rhs[k])) {
                            addToSet(first[idx], &firstCount[idx], rhs[k]);
                            changed = true;
                        }
                    }
                }
            }
        }
    }
}


void computeFollow() {
    for (int i = 0; i < ntCount; i++) {
        followCount[i] = 0;
    }
    
    // Add $ to start symbol
    addToSet(follow[0], &followCount[0], '$');
    
    bool changed = true;
    while (changed) {
        changed = false;
        
        for (int i = 0; i < prodCount; i++) {
            char *rhs = grammar[i].rhs;
            char lhs = grammar[i].lhs;
            
            for (int j = 0; rhs[j]; j++) {
                if (isNonTerminal(rhs[j])) {
                    int idx = getNTIndex(rhs[j]);
                    int k = j + 1;
                    bool allHaveEpsilon = true;
                    
                    while (rhs[k]) {
                        if (isTerminal(rhs[k])) {
                            if (!isInSet(follow[idx], followCount[idx], rhs[k])) {
                                addToSet(follow[idx], &followCount[idx], rhs[k]);
                                changed = true;
                            }
                            allHaveEpsilon = false;
                            break;
                        } else {
                            int nextIdx = getNTIndex(rhs[k]);
                            bool hasEpsilon = false;
                            
                            for (int l = 0; l < firstCount[nextIdx]; l++) {
                                if (first[nextIdx][l] == '@') {
                                    hasEpsilon = true;
                                } else {
                                    if (!isInSet(follow[idx], followCount[idx], first[nextIdx][l])) {
                                        addToSet(follow[idx], &followCount[idx], first[nextIdx][l]);
                                        changed = true;
                                    }
                                }
                            }
                            
                            if (!hasEpsilon) {
                                allHaveEpsilon = false;
                                break;
                            }
                        }
                        k++;
                    }
                    
                    if (allHaveEpsilon) {
                        int lhsIdx = getNTIndex(lhs);
                        for (int l = 0; l < followCount[lhsIdx]; l++) {
                            if (!isInSet(follow[idx], followCount[idx], follow[lhsIdx][l])) {
                                addToSet(follow[idx], &followCount[idx], follow[lhsIdx][l]);
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    }
}


void constructParsingTable() {
    // Initialize table
    for (int i = 0; i < ntCount; i++) {
        for (int j = 0; j < tCount; j++) {
            strcpy(parsingTable[i][j], "");
        }
    }
    
    for (int i = 0; i < prodCount; i++) {
        char lhs = grammar[i].lhs;
        char *rhs = grammar[i].rhs;
        int ntIdx = getNTIndex(lhs);
        
        // For each terminal in FIRST(rhs)
        if (rhs[0] == '@') {
            // Epsilon production - add to FOLLOW(lhs)
            for (int j = 0; j < followCount[ntIdx]; j++) {
                int tIdx = getTIndex(follow[ntIdx][j]);
                if (tIdx != -1) {
                    sprintf(parsingTable[ntIdx][tIdx], "%c->%s", lhs, rhs);
                }
            }
        } else if (isTerminal(rhs[0])) {
            int tIdx = getTIndex(rhs[0]);
            if (tIdx != -1) {
                sprintf(parsingTable[ntIdx][tIdx], "%c->%s", lhs, rhs);
            }
        } else {
            // First symbol is non-terminal
            int k = 0;
            bool allHaveEpsilon = true;
            
            while (rhs[k] && isNonTerminal(rhs[k])) {
                int rhsIdx = getNTIndex(rhs[k]);
                bool hasEpsilon = false;
                
                for (int j = 0; j < firstCount[rhsIdx]; j++) {
                    if (first[rhsIdx][j] == '@') {
                        hasEpsilon = true;
                    } else {
                        int tIdx = getTIndex(first[rhsIdx][j]);
                        if (tIdx != -1) {
                            sprintf(parsingTable[ntIdx][tIdx], "%c->%s", lhs, rhs);
                        }
                    }
                }
                
                if (!hasEpsilon) {
                    allHaveEpsilon = false;
                    break;
                }
                k++;
            }
            
            if (allHaveEpsilon) {
                if (rhs[k] == '\0') {
                    for (int j = 0; j < followCount[ntIdx]; j++) {
                        int tIdx = getTIndex(follow[ntIdx][j]);
                        if (tIdx != -1) {
                            sprintf(parsingTable[ntIdx][tIdx], "%c->%s", lhs, rhs);
                        }
                    }
                } else if (isTerminal(rhs[k])) {
                    int tIdx = getTIndex(rhs[k]);
                    if (tIdx != -1) {
                        sprintf(parsingTable[ntIdx][tIdx], "%c->%s", lhs, rhs);
                    }
                }
            }
        }
    }
}


void printGrammar() {
    for (int i = 0; i < prodCount; i++) {
        printf("%c -> %s\n", grammar[i].lhs, grammar[i].rhs);
    }
}


void printFirst() {
    for (int i = 0; i < ntCount; i++) {
        printf("FIRST(%c) = { ", nonTerminals[i]);
        for (int j = 0; j < firstCount[i]; j++) {
            printf("%c", first[i][j]);
            if (j < firstCount[i] - 1) printf(", ");
        }
        printf(" }\n");
    }
}


void printFollow() {
    for (int i = 0; i < ntCount; i++) {
        printf("FOLLOW(%c) = { ", nonTerminals[i]);
        for (int j = 0; j < followCount[i]; j++) {
            printf("%c", follow[i][j]);
            if (j < followCount[i] - 1) printf(", ");
        }
        printf(" }\n");
    }
}


void printParsingTable() {
    printf("\n%-8s", "");
    for (int j = 0; j < tCount; j++) {
        printf("%-15c", terminals[j]);
    }
    printf("\n");
    
    for (int i = 0; i < ntCount; i++) {
        printf("%-8c", nonTerminals[i]);
        for (int j = 0; j < tCount; j++) {
            if (strlen(parsingTable[i][j]) > 0) {
                printf("%-15s", parsingTable[i][j]);
            } else {
                printf("%-15s", "-");
            }
        }
        printf("\n");
    }
}


bool isNonTerminal(char c) {
    return isupper(c);
}


bool isTerminal(char c) {
    return (islower(c) || c == '+' || c == '*' || c == '(' || c == ')' || c == '$') && c != '@';
}


int getNTIndex(char c) {
    for (int i = 0; i < ntCount; i++) {
        if (nonTerminals[i] == c) return i;
    }
    return -1;
}


int getTIndex(char c) {
    for (int i = 0; i < tCount; i++) {
        if (terminals[i] == c) return i;
    }
    return -1;
}


void addToSet(char set[], int *count, char c) {
    if (!isInSet(set, *count, c)) {
        set[(*count)++] = c;
    }
}


bool isInSet(char set[], int count, char c) {
    for (int i = 0; i < count; i++) {
        if (set[i] == c) return true;
    }
    return false;
}


LR PARSER WITH CONSTRUCTION AND PARSING OF STRING


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>


#define MAX_STACK 100
#define MAX_INPUT 100
#define MAX_STATES 50
#define MAX_SYMBOLS 30
#define MAX_PROD 20
#define MAX_ITEMS 50


// Grammar Production Structure
typedef struct {
    char lhs;
    char rhs[20];
    int rhsLen;
} Production;


// LR(0) Item Structure
typedef struct {
    int prodNum;
    int dotPos;
} Item;


// State (Set of Items) Structure
typedef struct {
    Item items[MAX_ITEMS];
    int itemCount;
} State;


// Stack Structure
typedef struct {
    int state[MAX_STACK];
    char symbol[MAX_STACK];
    int top;
} Stack;


// Action: s=shift, r=reduce, a=accept, e=error
typedef struct {
    char action;
    int number;
} Action;


// Global Variables
Production productions[MAX_PROD];
int prodCount = 0;
char terminals[MAX_SYMBOLS];
char nonTerminals[MAX_SYMBOLS];
int tCount = 0, ntCount = 0;
char startSymbol;


Action actionTable[MAX_STATES][MAX_SYMBOLS];
int gotoTable[MAX_STATES][MAX_SYMBOLS];
State states[MAX_STATES];
int stateCount = 0;


char firstSets[MAX_SYMBOLS][MAX_SYMBOLS];
char followSets[MAX_SYMBOLS][MAX_SYMBOLS];
int firstCount[MAX_SYMBOLS];
int followCount[MAX_SYMBOLS];


// Function Prototypes
void inputGrammar();
void extractSymbols();
void augmentGrammar();
void computeFirstSets();
void computeFollowSets();
void buildLR0Automaton();
void closure(State *state);
State gotoState(State *s, char symbol);
bool stateExists(State *s, int *index);
bool itemExists(State *s, Item item);
void addItem(State *s, Item item);
void constructSLRTable();
void printGrammar();
void printStates();
void printParsingTable();
void initStack(Stack *s);
void push(Stack *s, int state, char symbol);
void pop(Stack *s, int count);
int getTerminalIndex(char c);
int getNonTerminalIndex(char c);
bool parseInput(char *input);
void printStep(int step, Stack *s, char *input, int inputPos, char *action);
void printProduction(int prodNum);
void printItem(Item item);
bool isTerminal(char c);
bool isNonTerminal(char c);


int main() {
    char input[MAX_INPUT];
    
    printf("==============================================\n");
    printf("   LR PARSER WITH CLOSURE CONSTRUCTION\n");
    printf("==============================================\n\n");
    
    inputGrammar();
    extractSymbols();
    augmentGrammar();
    
    printf("\n--- Augmented Grammar ---\n");
    printGrammar();
    
    printf("\n--- Computing FIRST Sets ---\n");
    computeFirstSets();
    
    printf("\n--- Computing FOLLOW Sets ---\n");
    computeFollowSets();
    
    printf("\n--- Building LR(0) Automaton ---\n");
    buildLR0Automaton();
    
    printf("\n--- LR(0) States ---\n");
    printStates();
    
    printf("\n--- Constructing SLR Parsing Table ---\n");
    constructSLRTable();
    
    printParsingTable();
    
    // Parse multiple inputs
    while (true) {
        printf("\n==============================================\n");
        printf("Enter input string (or 'exit' to quit):\n");
        printf("Input: ");
        scanf("%s", input);
        
        if (strcmp(input, "exit") == 0) {
            break;
        }
        
        strcat(input, "$");
        
        printf("\n--- Parsing: %s ---\n\n", input);
        
        if (parseInput(input)) {
            printf("\n✓ INPUT STRING ACCEPTED!\n");
        } else {
            printf("\n✗ INPUT STRING REJECTED!\n");
        }
    }
    
    return 0;
}


void inputGrammar() {
    printf("Enter number of productions: ");
    scanf("%d", &prodCount);
    getchar();
    
    printf("Enter start symbol: ");
    scanf("%c", &startSymbol);
    getchar();
    
    printf("\nEnter productions (format: E=E+T or E=T or F=i):\n");
    printf("Note: Use lowercase for terminals, uppercase for non-terminals\n");
    printf("      Use @ for epsilon (if needed)\n\n");
    
    for (int i = 0; i < prodCount; i++) {
        char input[50];
        printf("Production %d: ", i + 1);
        fgets(input, 50, stdin);
        input[strcspn(input, "\n")] = 0;
        
        char *eq = strchr(input, '=');
        if (eq) {
            productions[i].lhs = input[0];
            strcpy(productions[i].rhs, eq + 1);
            productions[i].rhsLen = strlen(productions[i].rhs);
        }
    }
}


void extractSymbols() {
    tCount = 0;
    ntCount = 0;
    
    for (int i = 0; i < prodCount; i++) {
        bool found = false;
        for (int j = 0; j < ntCount; j++) {
            if (nonTerminals[j] == productions[i].lhs) {
                found = true;
                break;
            }
        }
        if (!found) {
            nonTerminals[ntCount++] = productions[i].lhs;
        }
    }
    
    for (int i = 0; i < prodCount; i++) {
        for (int j = 0; j < productions[i].rhsLen; j++) {
            char c = productions[i].rhs[j];
            if (!isupper(c) && c != '@') {
                bool found = false;
                for (int k = 0; k < tCount; k++) {
                    if (terminals[k] == c) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    terminals[tCount++] = c;
                }
            }
        }
    }
    
    terminals[tCount++] = '$';
}


void augmentGrammar() {
    for (int i = prodCount; i > 0; i--) {
        productions[i] = productions[i-1];
    }
    
    productions[0].lhs = '\'';
    productions[0].rhs[0] = startSymbol;
    productions[0].rhs[1] = '\0';
    productions[0].rhsLen = 1;
    prodCount++;
    
    for (int i = ntCount; i > 0; i--) {
        nonTerminals[i] = nonTerminals[i-1];
    }
    nonTerminals[0] = '\'';
    ntCount++;
}


void computeFirstSets() {
    for (int i = 0; i < ntCount; i++) {
        firstCount[i] = 0;
    }
    
    bool changed = true;
    while (changed) {
        changed = false;
        
        for (int i = 0; i < prodCount; i++) {
            char lhs = productions[i].lhs;
            char *rhs = productions[i].rhs;
            int lhsIdx = getNonTerminalIndex(lhs);
            
            if (lhsIdx == -1) continue;
            
            if (rhs[0] == '@') {
                bool found = false;
                for (int j = 0; j < firstCount[lhsIdx]; j++) {
                    if (firstSets[lhsIdx][j] == '@') {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    firstSets[lhsIdx][firstCount[lhsIdx]++] = '@';
                    changed = true;
                }
            } else if (isTerminal(rhs[0])) {
                bool found = false;
                for (int j = 0; j < firstCount[lhsIdx]; j++) {
                    if (firstSets[lhsIdx][j] == rhs[0]) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    firstSets[lhsIdx][firstCount[lhsIdx]++] = rhs[0];
                    changed = true;
                }
            } else if (isNonTerminal(rhs[0])) {
                int rhsIdx = getNonTerminalIndex(rhs[0]);
                if (rhsIdx != -1) {
                    for (int j = 0; j < firstCount[rhsIdx]; j++) {
                        if (firstSets[rhsIdx][j] != '@') {
                            bool found = false;
                            for (int k = 0; k < firstCount[lhsIdx]; k++) {
                                if (firstSets[lhsIdx][k] == firstSets[rhsIdx][j]) {
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                firstSets[lhsIdx][firstCount[lhsIdx]++] = firstSets[rhsIdx][j];
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    }
    
    printf("FIRST Sets:\n");
    for (int i = 0; i < ntCount; i++) {
        printf("FIRST(%c) = { ", nonTerminals[i]);
        for (int j = 0; j < firstCount[i]; j++) {
            printf("%c ", firstSets[i][j]);
        }
        printf("}\n");
    }
}


void computeFollowSets() {
    for (int i = 0; i < ntCount; i++) {
        followCount[i] = 0;
    }
    
    followSets[0][followCount[0]++] = '$';
    
    bool changed = true;
    while (changed) {
        changed = false;
        
        for (int i = 0; i < prodCount; i++) {
            char *rhs = productions[i].rhs;
            int lhsIdx = getNonTerminalIndex(productions[i].lhs);
            
            for (int j = 0; j < productions[i].rhsLen; j++) {
                if (isNonTerminal(rhs[j])) {
                    int ntIdx = getNonTerminalIndex(rhs[j]);
                    
                    if (j == productions[i].rhsLen - 1) {
                        for (int k = 0; k < followCount[lhsIdx]; k++) {
                            bool found = false;
                            for (int l = 0; l < followCount[ntIdx]; l++) {
                                if (followSets[ntIdx][l] == followSets[lhsIdx][k]) {
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                followSets[ntIdx][followCount[ntIdx]++] = followSets[lhsIdx][k];
                                changed = true;
                            }
                        }
                    } else if (isTerminal(rhs[j+1])) {
                        bool found = false;
                        for (int k = 0; k < followCount[ntIdx]; k++) {
                            if (followSets[ntIdx][k] == rhs[j+1]) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            followSets[ntIdx][followCount[ntIdx]++] = rhs[j+1];
                            changed = true;
                        }
                    } else if (isNonTerminal(rhs[j+1])) {
                        int nextIdx = getNonTerminalIndex(rhs[j+1]);
                        for (int k = 0; k < firstCount[nextIdx]; k++) {
                            if (firstSets[nextIdx][k] != '@') {
                                bool found = false;
                                for (int l = 0; l < followCount[ntIdx]; l++) {
                                    if (followSets[ntIdx][l] == firstSets[nextIdx][k]) {
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    followSets[ntIdx][followCount[ntIdx]++] = firstSets[nextIdx][k];
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    printf("\nFOLLOW Sets:\n");
    for (int i = 0; i < ntCount; i++) {
        printf("FOLLOW(%c) = { ", nonTerminals[i]);
        for (int j = 0; j < followCount[i]; j++) {
            printf("%c ", followSets[i][j]);
        }
        printf("}\n");
    }
}


void closure(State *state) {
    bool changed = true;
    
    while (changed) {
        changed = false;
        int currentCount = state->itemCount;
        
        for (int i = 0; i < currentCount; i++) {
            Item item = state->items[i];
            char *rhs = productions[item.prodNum].rhs;
            
            if (item.dotPos < strlen(rhs)) {
                char nextSymbol = rhs[item.dotPos];
                
                if (isNonTerminal(nextSymbol)) {
                    for (int j = 0; j < prodCount; j++) {
                        if (productions[j].lhs == nextSymbol) {
                            Item newItem;
                            newItem.prodNum = j;
                            newItem.dotPos = 0;
                            
                            if (!itemExists(state, newItem)) {
                                addItem(state, newItem);
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    }
}


State gotoState(State *s, char symbol) {
    State newState;
    newState.itemCount = 0;
    
    for (int i = 0; i < s->itemCount; i++) {
        Item item = s->items[i];
        char *rhs = productions[item.prodNum].rhs;
        
        if (item.dotPos < strlen(rhs) && rhs[item.dotPos] == symbol) {
            Item newItem;
            newItem.prodNum = item.prodNum;
            newItem.dotPos = item.dotPos + 1;
            addItem(&newState, newItem);
        }
    }
    
    if (newState.itemCount > 0) {
        closure(&newState);
    }
    
    return newState;
}


bool stateExists(State *s, int *index) {
    for (int i = 0; i < stateCount; i++) {
        if (states[i].itemCount != s->itemCount) continue;
        
        bool same = true;
        for (int j = 0; j < s->itemCount; j++) {
            bool found = false;
            for (int k = 0; k < states[i].itemCount; k++) {
                if (states[i].items[k].prodNum == s->items[j].prodNum &&
                    states[i].items[k].dotPos == s->items[j].dotPos) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                same = false;
                break;
            }
        }
        
        if (same) {
            *index = i;
            return true;
        }
    }
    return false;
}


bool itemExists(State *s, Item item) {
    for (int i = 0; i < s->itemCount; i++) {
        if (s->items[i].prodNum == item.prodNum && 
            s->items[i].dotPos == item.dotPos) {
            return true;
        }
    }
    return false;
}


void addItem(State *s, Item item) {
    if (!itemExists(s, item)) {
        s->items[s->itemCount++] = item;
    }
}


void buildLR0Automaton() {
    stateCount = 0;
    
    // Create I0
    State I0;
    I0.itemCount = 0;
    Item startItem;
    startItem.prodNum = 0;
    startItem.dotPos = 0;
    addItem(&I0, startItem);
    closure(&I0);
    
    states[stateCount++] = I0;
    
    // Build states
    for (int i = 0; i < stateCount; i++) {
        // Try all symbols
        for (int j = 0; j < ntCount; j++) {
            State newState = gotoState(&states[i], nonTerminals[j]);
            if (newState.itemCount > 0) {
                int index;
                if (!stateExists(&newState, &index)) {
                    states[stateCount++] = newState;
                }
            }
        }
        
        for (int j = 0; j < tCount - 1; j++) {
            State newState = gotoState(&states[i], terminals[j]);
            if (newState.itemCount > 0) {
                int index;
                if (!stateExists(&newState, &index)) {
                    states[stateCount++] = newState;
                }
            }
        }
    }
    
    printf("Total states: %d\n", stateCount);
}


void constructSLRTable() {
    // Initialize tables
    for (int i = 0; i < MAX_STATES; i++) {
        for (int j = 0; j < MAX_SYMBOLS; j++) {
            actionTable[i][j].action = 'e';
            actionTable[i][j].number = -1;
            gotoTable[i][j] = -1;
        }
    }
    
    for (int i = 0; i < stateCount; i++) {
        for (int j = 0; j < states[i].itemCount; j++) {
            Item item = states[i].items[j];
            char *rhs = productions[item.prodNum].rhs;
            
            if (item.dotPos < strlen(rhs)) {
                char nextSymbol = rhs[item.dotPos];
                
                if (isTerminal(nextSymbol)) {
                    State nextState = gotoState(&states[i], nextSymbol);
                    int index;
                    if (stateExists(&nextState, &index)) {
                        int tIdx = getTerminalIndex(nextSymbol);
                        actionTable[i][tIdx].action = 's';
                        actionTable[i][tIdx].number = index;
                    }
                } else if (isNonTerminal(nextSymbol)) {
                    State nextState = gotoState(&states[i], nextSymbol);
                    int index;
                    if (stateExists(&nextState, &index)) {
                        int ntIdx = getNonTerminalIndex(nextSymbol);
                        gotoTable[i][ntIdx] = index;
                    }
                }
            } else {
                if (item.prodNum == 0) {
                    int tIdx = getTerminalIndex('$');
                    actionTable[i][tIdx].action = 'a';
                } else {
                    int lhsIdx = getNonTerminalIndex(productions[item.prodNum].lhs);
                    for (int k = 0; k < followCount[lhsIdx]; k++) {
                        int tIdx = getTerminalIndex(followSets[lhsIdx][k]);
                        if (tIdx != -1) {
                            actionTable[i][tIdx].action = 'r';
                            actionTable[i][tIdx].number = item.prodNum;
                        }
                    }
                }
            }
        }
    }
}


void printGrammar() {
    for (int i = 0; i < prodCount; i++) {
        printf("%d. ", i);
        printProduction(i);
    }
}


void printProduction(int prodNum) {
    printf("%c -> %s\n", productions[prodNum].lhs, productions[prodNum].rhs);
}


void printItem(Item item) {
    printf("%c -> ", productions[item.prodNum].lhs);
    char *rhs = productions[item.prodNum].rhs;
    for (int i = 0; i <= strlen(rhs); i++) {
        if (i == item.dotPos) printf(".");
        if (i < strlen(rhs)) printf("%c", rhs[i]);
    }
}


void printStates() {
    for (int i = 0; i < stateCount; i++) {
        printf("\nState I%d:\n", i);
        for (int j = 0; j < states[i].itemCount; j++) {
            printf("  ");
            printItem(states[i].items[j]);
            printf("\n");
        }
    }
}


void printParsingTable() {
    printf("\n========================================\n");
    printf("          SLR PARSING TABLE\n");
    printf("========================================\n\n");
    
    printf("%-8s", "State");
    printf("%-15s", "ACTION");
    for (int i = 0; i < tCount; i++) {
        printf("%-8c", terminals[i]);
    }
    printf("%-15s", "GOTO");
    for (int i = 1; i < ntCount; i++) {
        printf("%-8c", nonTerminals[i]);
    }
    printf("\n");
    
    for (int i = 0; i < 80; i++) printf("-");
    printf("\n");
    
    for (int i = 0; i < stateCount; i++) {
        printf("%-8d", i);
        printf("%-15s", "");
        
        for (int j = 0; j < tCount; j++) {
            int tIdx = getTerminalIndex(terminals[j]);
            if (actionTable[i][tIdx].action == 's') {
                printf("s%-7d", actionTable[i][tIdx].number);
            } else if (actionTable[i][tIdx].action == 'r') {
                printf("r%-7d", actionTable[i][tIdx].number);
            } else if (actionTable[i][tIdx].action == 'a') {
                printf("%-8s", "acc");
            } else {
                printf("%-8s", "-");
            }
        }
        
        printf("%-15s", "");
        
        for (int j = 1; j < ntCount; j++) {
            int ntIdx = getNonTerminalIndex(nonTerminals[j]);
            if (gotoTable[i][ntIdx] != -1) {
                printf("%-8d", gotoTable[i][ntIdx]);
            } else {
                printf("%-8s", "-");
            }
        }
        printf("\n");
    }
}


void initStack(Stack *s) {
    s->top = -1;
    push(s, 0, '$');
}


void push(Stack *s, int state, char symbol) {
    s->top++;
    s->state[s->top] = state;
    s->symbol[s->top] = symbol;
}


void pop(Stack *s, int count) {
    s->top -= count;
}


int getTerminalIndex(char c) {
    for (int i = 0; i < tCount; i++) {
        if (terminals[i] == c) return i;
    }
    return -1;
}


int getNonTerminalIndex(char c) {
    for (int i = 0; i < ntCount; i++) {
        if (nonTerminals[i] == c) return i;
    }
    return -1;
}


bool isTerminal(char c) {
    return !isupper(c) && c != '@';
}


bool isNonTerminal(char c) {
    return isupper(c) || c == '\'';
}


bool parseInput(char *input) {
    Stack stack;
    initStack(&stack);
    int inputPos = 0;
    int step = 1;
    
    printf("%-6s %-20s %-20s %-20s\n", "Step", "Stack", "Input", "Action");
    printf("----------------------------------------------------------------\n");
    
    while (true) {
        int currentState = stack.state[stack.top];
        char currentInput = input[inputPos];
        int tIdx = getTerminalIndex(currentInput);
        
        if (tIdx == -1) {
            printf("Error: Invalid input symbol '%c'\n", currentInput);
            return false;
        }
        
        Action action = actionTable[currentState][tIdx];
        
        // Print current step
        printf("%-6d ", step++);
        for (int i = 0; i <= stack.top; i++) {
            printf("%c", stack.symbol[i]);
        }
        printf("%-20s", "");
        printf("%-20s", input + inputPos);
        
        if (action.action == 's') {
            printf("Shift %d\n", action.number);
            push(&stack, action.number, currentInput);
            inputPos++;
        } else if (action.action == 'r') {
            printf("Reduce by production %d\n", action.number);
            int prodLen = productions[action.number].rhsLen;
            pop(&stack, prodLen);
            
            char lhs = productions[action.number].lhs;
            int topState = stack.state[stack.top];
            int ntIdx = getNonTerminalIndex(lhs);
            int gotoSt = gotoTable[topState][ntIdx];
            
            if (gotoSt == -1) {
                printf("Error: No goto entry\n");
                return false;
            }
            
            push(&stack, gotoSt, lhs);
        } else if (action.action == 'a') {
            printf("Accept\n");
            return true;
        } else {
            printf("Error\n");
            return false;
        }
    }
}


void printStep(int step, Stack *s, char *input, int inputPos, char *action) {
    printf("%-6d ", step);
    for (int i = 0; i <= s->top; i++) {
        printf("%d", s->state[i]);
    }
    printf(" | ");
    for (int i = 0; i <= s->top; i++) {
        printf("%c", s->symbol[i]);
    }
    printf(" | %s | %s\n", input + inputPos, action);
}


TAC


#include <stdio.h>
#include <string.h>
#include <ctype.h>


#define MAX 100


char stack[MAX];
int top = -1;
int tempCount = 1;


// Quadruple structure
typedef struct {
    char op;
    char arg1[5];
    char arg2[5];
    char result[5];
} Quad;


// Triple structure
typedef struct {
    char op;
    char arg1[5];
    char arg2[5];
} Triple;


Quad quadList[50];
Triple tripleList[50];
int quadIndex = 0;
int tripleIndex = 0;


void push(char c) { stack[++top] = c; }
char pop() { return (top==-1) ? '\0' : stack[top--]; }
char peek() { return (top==-1) ? '\0' : stack[top]; }
int precedence(char c) {
    if(c=='+'||c=='-') return 1;
    if(c=='*'||c=='/') return 2;
    return 0;
}


// Convert infix to postfix
void infixToPostfix(char* expr, char* postfix) {
    int j=0;
    for(int i=0; expr[i]; i++) {
        if(isalpha(expr[i])) {
            postfix[j++] = expr[i];
        } else if(expr[i]=='(') {
            push('(');
        } else if(expr[i]==')') {
            while(top!=-1 && peek()!='(')
                postfix[j++] = pop();
            pop(); // remove '('
        } else { // operator
            while(top!=-1 && precedence(peek())>=precedence(expr[i]))
                postfix[j++] = pop();
            push(expr[i]);
        }
    }
    while(top!=-1)
        postfix[j++] = pop();
    postfix[j] = '\0';
}


// Generate TAC, Quadruple, and Triple
void generateTACandTables(char* postfix, char* lhs) {
    char stackOperands[50][5];
    int opTop=-1;


    for(int i=0; postfix[i]; i++) {
        if(isalpha(postfix[i])) {
            sprintf(stackOperands[++opTop], "%c", postfix[i]);
        } else { // operator
            char op2[5], op1[5], temp[5];
            strcpy(op2, stackOperands[opTop--]);
            strcpy(op1, stackOperands[opTop--]);
            sprintf(temp, "t%d", tempCount++);


            // TAC
            printf("%s = %s %c %s\n", temp, op1, postfix[i], op2);


            // Quadruple
            quadList[quadIndex].op = postfix[i];
            strcpy(quadList[quadIndex].arg1, op1);
            strcpy(quadList[quadIndex].arg2, op2);
            strcpy(quadList[quadIndex].result, temp);
            quadIndex++;


            // Triple
            tripleList[tripleIndex].op = postfix[i];
            strcpy(tripleList[tripleIndex].arg1, op1);
            strcpy(tripleList[tripleIndex].arg2, op2);
            tripleIndex++;


            strcpy(stackOperands[++opTop], temp);
        }
    }


    // Final assignment to LHS
    printf("%s = %s\n\n", lhs, stackOperands[opTop]);
}


void printQuadruples() {
    printf("Quadruples Table:\n");
    printf("Result\tArg1\tOp\tArg2\n");
    for(int i=0;i<quadIndex;i++)
        printf("%s\t%s\t%c\t%s\n", quadList[i].result, quadList[i].arg1, quadList[i].op, quadList[i].arg2);
    printf("\n");
}


void printTriples() {
    printf("Triples Table:\n");
    printf("Index\tOp\tArg1\tArg2\n");
    for(int i=0;i<tripleIndex;i++)
        printf("%d\t%c\t%s\t%s\n", i, tripleList[i].op, tripleList[i].arg1, tripleList[i].arg2);
    printf("\n");
}


int main() {
    char code[100], postfix[100];
    printf("Enter arithmetic statement (e.g., a=b+c*d): ");
    scanf("%s", code);


    char *eq = strchr(code,'=');
    if(eq) {
        char lhs[10];
        strncpy(lhs, code, eq-code);
        lhs[eq-code] = '\0';
        char *rhs = eq+1;


        infixToPostfix(rhs, postfix);
        generateTACandTables(postfix, lhs);
        printQuadruples();
        printTriples();
    } else {
        printf("Invalid statement.\n");
    }


    return 0;
}


NFA TO DFA


#include <stdio.h>
#include <string.h>


#define MAX_STATES 10
#define MAX_SYMBOLS 10
#define MAX_DFA_STATES 100


int nfa[MAX_STATES][MAX_SYMBOLS][MAX_STATES];
int nfa_states, nfa_symbols;


typedef struct {
    int states[MAX_STATES];
    int count;
} StateSet;


StateSet dfa[MAX_DFA_STATES];
int dfa_count = 0;
int dfa_transitions[MAX_DFA_STATES][MAX_SYMBOLS];


int is_in_dfa(StateSet s) {
    for (int i = 0; i < dfa_count; i++) {
        if (dfa[i].count == s.count) {
            int same = 1;
            for (int j = 0; j < s.count; j++)
                if (dfa[i].states[j] != s.states[j])
                    same = 0;
            if (same) return i;
        }
    }
    return -1;
}


StateSet union_set(StateSet s1, StateSet s2) {
    StateSet result = s1;
    for (int i = 0; i < s2.count; i++) {
        int found = 0;
        for (int j = 0; j < result.count; j++)
            if (s2.states[i] == result.states[j]) {
                found = 1;
                break;
            }
        if (!found) {
            result.states[result.count++] = s2.states[i];
        }
    }
    return result;
}


StateSet move(StateSet s, int symbol) {
    StateSet result;
    result.count = 0;
    for (int i = 0; i < s.count; i++) {
        int from = s.states[i];
        for (int j = 0; j < nfa_states; j++) {
            if (nfa[from][symbol][j]) {
                int found = 0;
                for (int k = 0; k < result.count; k++)
                    if (result.states[k] == j) found = 1;
                if (!found) result.states[result.count++] = j;
            }
        }
    }
    return result;
}


int main() {
    printf("Enter number of NFA states: ");
    scanf("%d", &nfa_states);
    printf("Enter number of input symbols: ");
    scanf("%d", &nfa_symbols);


    memset(nfa, 0, sizeof(nfa));


    printf("Enter NFA transition table (1 if transition exists, 0 otherwise):\n");
    for (int i = 0; i < nfa_states; i++) {
        for (int j = 0; j < nfa_symbols; j++) {
            printf("State %d, Symbol %d: ", i, j);
            for (int k = 0; k < nfa_states; k++) {
                scanf("%d", &nfa[i][j][k]);
            }
        }
    }


    // Initialize DFA with start state
    dfa[0].count = 1;
    dfa[0].states[0] = 0;
    dfa_count = 1;


    for (int i = 0; i < dfa_count; i++) {
        for (int j = 0; j < nfa_symbols; j++) {
            StateSet new_set = move(dfa[i], j);
            int idx = is_in_dfa(new_set);
            if (idx == -1 && new_set.count > 0) {
                dfa[dfa_count] = new_set;
                dfa_transitions[i][j] = dfa_count;
                dfa_count++;
            } else {
                dfa_transitions[i][j] = idx;
            }
        }
    }


    // Print DFA transition table
    printf("\nDFA Transition Table:\n");
    for (int i = 0; i < dfa_count; i++) {
        printf("DFA state %d: {", i);
        for (int k = 0; k < dfa[i].count; k++) {
            printf("%d", dfa[i].states[k]);
            if (k != dfa[i].count - 1) printf(",");
        }
        printf("} -> ");
        for (int j = 0; j < nfa_symbols; j++) {
            if (dfa_transitions[i][j] != -1)
                printf("Symbol %d: %d  ", j, dfa_transitions[i][j]);
        }
        printf("\n");
    }


    return 0;
}

OPERATOR PRECEDENCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX 100

typedef struct {
    char left;
    char right[MAX];
} Production;

Production grammar[MAX];
int numProductions = 0;

// Operator precedence table
char precedenceTable[MAX][MAX];
char terminals[MAX];
char nonTerminals[MAX];
int numTerminals = 0;
int numNonTerminals = 0;

// Stack for parsing
typedef struct {
    char items[MAX];
    int top;
} Stack;

void initStack(Stack *s) {
    s->top = -1;
}

int isEmpty(Stack *s) {
    return s->top == -1;
}

void push(Stack *s, char val) {
    if (s->top < MAX - 1) {
        s->items[++(s->top)] = val;
    }
}

char pop(Stack *s) {
    if (!isEmpty(s)) {
        return s->items[(s->top)--];
    }
    return '\0';
}

char peek(Stack *s) {
    if (!isEmpty(s)) {
        return s->items[s->top];
    }
    return '\0';
}

int isTerminal(char ch) {
    for (int i = 0; i < numTerminals; i++) {
        if (terminals[i] == ch) return 1;
    }
    return 0;
}

int isNonTerminal(char ch) {
    for (int i = 0; i < numNonTerminals; i++) {
        if (nonTerminals[i] == ch) return 1;
    }
    return 0;
}

void addTerminal(char ch) {
    for (int i = 0; i < numTerminals; i++) {
        if (terminals[i] == ch) return;
    }
    terminals[numTerminals++] = ch;
}

void addNonTerminal(char ch) {
    for (int i = 0; i < numNonTerminals; i++) {
        if (nonTerminals[i] == ch) return;
    }
    nonTerminals[numNonTerminals++] = ch;
}

void inputGrammar() {
    printf("Enter number of productions: ");
    scanf("%d", &numProductions);
    getchar(); // consume newline
    
    printf("\nEnter productions (format: E->E+T or E->T):\n");
    for (int i = 0; i < numProductions; i++) {
        printf("Production %d: ", i + 1);
        char line[MAX];
        fgets(line, MAX, stdin);
        line[strcspn(line, "\n")] = '\0';
        
        // Parse production: A->alpha
        char *arrow = strstr(line, "->");
        if (arrow) {
            grammar[i].left = line[0];
            strcpy(grammar[i].right, arrow + 2);
            
            // Extract terminals and non-terminals
            addNonTerminal(grammar[i].left);
            for (int j = 0; grammar[i].right[j] != '\0'; j++) {
                if (isupper(grammar[i].right[j])) {
                    addNonTerminal(grammar[i].right[j]);
                } else if (grammar[i].right[j] != 'e') { // 'e' for epsilon
                    addTerminal(grammar[i].right[j]);
                }
            }
        }
    }
    
    // Add $ as end marker
    addTerminal('$');
    
    printf("\nTerminals: ");
    for (int i = 0; i < numTerminals; i++) {
        printf("%c ", terminals[i]);
    }
    printf("\nNon-terminals: ");
    for (int i = 0; i < numNonTerminals; i++) {
        printf("%c ", nonTerminals[i]);
    }
    printf("\n");
}

void buildPrecedenceTable() {
    printf("\nEnter operator precedence relations:\n");
    printf("Use: < (less than), > (greater than), = (equal)\n");
    printf("Format: operator1 relation operator2 (e.g., + < *)\n");
    printf("Enter 'done' when finished\n\n");
    
    // Initialize table
    for (int i = 0; i < numTerminals; i++) {
        for (int j = 0; j < numTerminals; j++) {
            precedenceTable[i][j] = ' ';
        }
    }
    
    char op1, op2, relation;
    char line[MAX];
    
    while (1) {
        printf("Relation: ");
        fgets(line, MAX, stdin);
        line[strcspn(line, "\n")] = '\0';
        
        if (strcmp(line, "done") == 0) break;
        
        if (sscanf(line, " %c %c %c", &op1, &relation, &op2) == 3) {
            int idx1 = -1, idx2 = -1;
            for (int i = 0; i < numTerminals; i++) {
                if (terminals[i] == op1) idx1 = i;
                if (terminals[i] == op2) idx2 = i;
            }
            
            if (idx1 != -1 && idx2 != -1) {
                precedenceTable[idx1][idx2] = relation;
            }
        }
    }
    
    // Display precedence table
    printf("\nOperator Precedence Table:\n");
    printf("   ");
    for (int j = 0; j < numTerminals; j++) {
        printf("%c ", terminals[j]);
    }
    printf("\n");
    
    for (int i = 0; i < numTerminals; i++) {
        printf("%c  ", terminals[i]);
        for (int j = 0; j < numTerminals; j++) {
            printf("%c ", precedenceTable[i][j]);
        }
        printf("\n");
    }
}

char getPrecedence(char top, char input) {
    int idx1 = -1, idx2 = -1;
    
    for (int i = 0; i < numTerminals; i++) {
        if (terminals[i] == top) idx1 = i;
        if (terminals[i] == input) idx2 = i;
    }
    
    if (idx1 != -1 && idx2 != -1) {
        return precedenceTable[idx1][idx2];
    }
    return ' ';
}

int findHandle(char *str, int *start, int *end) {
    // Find rightmost handle in the stack
    for (int i = strlen(str) - 1; i >= 0; i--) {
        for (int j = 0; j < numProductions; j++) {
            int len = strlen(grammar[j].right);
            if (i >= len - 1) {
                int match = 1;
                for (int k = 0; k < len; k++) {
                    if (str[i - len + 1 + k] != grammar[j].right[k]) {
                        match = 0;
                        break;
                    }
                }
                if (match) {
                    *start = i - len + 1;
                    *end = i;
                    return j;
                }
            }
        }
    }
    return -1;
}

void parse(char *input) {
    Stack stack;
    initStack(&stack);
    
    char str[MAX];
    strcat(input, "$"); // Add end marker
    
    int i = 0;
    push(&stack, '$');
    
    printf("\n%-20s %-20s %-10s\n", "Stack", "Input", "Action");
    printf("--------------------------------------------------------\n");
    
    while (1) {
        // Build stack string for display
        strcpy(str, "");
        for (int j = 0; j <= stack.top; j++) {
            char temp[2] = {stack.items[j], '\0'};
            strcat(str, temp);
        }
        
        printf("%-20s %-20s ", str, &input[i]);
        
        char topChar = peek(&stack);
        
        // Skip non-terminals on stack
        while (isNonTerminal(topChar) && !isEmpty(&stack)) {
            pop(&stack);
            topChar = peek(&stack);
        }
        
        char inputChar = input[i];
        
        if (topChar == '$' && inputChar == '$') {
            printf("Accept\n");
            break;
        }
        
        char relation = getPrecedence(topChar, inputChar);
        
        if (relation == '<' || relation == '=') {
            push(&stack, inputChar);
            i++;
            printf("Shift %c\n", inputChar);
        } else if (relation == '>') {
            // Reduce
            strcpy(str, "");
            for (int j = 0; j <= stack.top; j++) {
                char temp[2] = {stack.items[j], '\0'};
                strcat(str, temp);
            }
            
            int start, end;
            int prodIdx = findHandle(str, &start, &end);
            
            if (prodIdx != -1) {
                // Pop handle
                int handleLen = end - start + 1;
                for (int j = 0; j < handleLen; j++) {
                    pop(&stack);
                }
                push(&stack, grammar[prodIdx].left);
                printf("Reduce by %c->%s\n", grammar[prodIdx].left, grammar[prodIdx].right);
            } else {
                printf("Error: No production found\n");
                break;
            }
        } else {
            printf("Error: No precedence relation\n");
            break;
        }
    }
}

int main() {
    printf("========================================\n");
    printf("  OPERATOR PRECEDENCE PARSER\n");
    printf("========================================\n\n");
    
    inputGrammar();
    buildPrecedenceTable();
    
    char input[MAX];
    printf("\nEnter input string to parse: ");
    scanf("%s", input);
    
    parse(input);
    
    return 0;
}

DAG, SYNTAX TREE, QUADRUPLES, TRIPLES, INDIRECT TRIPLES

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX 100

// Structure for Syntax Tree Node
typedef struct TreeNode {
    char data;
    struct TreeNode *left, *right;
    int isUnary; // Flag for unary operators
} TreeNode;

// Structure for Quadruple
typedef struct {
    char op;
    char arg1[10];
    char arg2[10];
    char result[10];
} Quadruple;

// Structure for Triple
typedef struct {
    char op;
    char arg1[10];
    char arg2[10];
} Triple;

// Structure for DAG Node
typedef struct DAGNode {
    char data;
    struct DAGNode *left, *right;
    int id;
    int isUnary;
} DAGNode;

// Global variables
Quadruple quads[MAX];
Triple triples[MAX];
int quadCount = 0, tripleCount = 0, tempCount = 0;
DAGNode* dagNodes[MAX];
int dagCount = 0;

// Stack for operators and operands
char opStack[MAX];
TreeNode* nodeStack[MAX];
int opTop = -1, nodeTop = -1;

// Function prototypes
int precedence(char op);
int isOperator(char c);
TreeNode* createNode(char data, int isUnary);
TreeNode* buildSyntaxTree(char* postfix);
void inorderTraversal(TreeNode* root);
void generateQuadruples(TreeNode* root, char* result);
void generateTriples(TreeNode* root);
void printQuadruples();
void printTriples();
void printIndirectTriples();
DAGNode* createDAGNode(char data, int id, int isUnary);
DAGNode* findDAGNode(char op, DAGNode* left, DAGNode* right, int isUnary);
DAGNode* buildDAG(char* postfix);
void printTree(TreeNode* root, char* prefix, int isRight);
void printDAGGraph(DAGNode* root);
void printDAGTree(DAGNode* root, char* prefix, int isRight);
char* infixToPostfix(char* infix);

// Check precedence of operators
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '~') return 3; // Unary minus (higher precedence)
    return 0;
}

// Check if character is an operator
int isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '~');
}

// Create a new tree node
TreeNode* createNode(char data, int isUnary) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->data = data;
    node->left = node->right = NULL;
    node->isUnary = isUnary;
    return node;
}

// Convert infix to postfix with unary operator support
char* infixToPostfix(char* infix) {
    static char postfix[MAX];
    int i, j = 0;
    opTop = -1;
    int lastWasOperator = 1; // Track if last token was operator or '('
    
    for (i = 0; infix[i] != '\0'; i++) {
        if (isspace(infix[i])) continue;
        
        if (isalnum(infix[i])) {
            postfix[j++] = infix[i];
            lastWasOperator = 0;
        }
        else if (infix[i] == '(') {
            opStack[++opTop] = infix[i];
            lastWasOperator = 1;
        }
        else if (infix[i] == ')') {
            while (opTop >= 0 && opStack[opTop] != '(') {
                postfix[j++] = opStack[opTop--];
            }
            if (opTop >= 0) opTop--; // Pop '('
            lastWasOperator = 0;
        }
        else if (infix[i] == '-' && lastWasOperator) {
            // Unary minus - convert to '~'
            while (opTop >= 0 && precedence(opStack[opTop]) >= precedence('~')) {
                postfix[j++] = opStack[opTop--];
            }
            opStack[++opTop] = '~';
            lastWasOperator = 1;
        }
        else if (infix[i] == '+' && lastWasOperator) {
            // Unary plus - just skip it
            lastWasOperator = 1;
        }
        else if (isOperator(infix[i])) {
            while (opTop >= 0 && opStack[opTop] != '(' && 
                   precedence(opStack[opTop]) >= precedence(infix[i])) {
                postfix[j++] = opStack[opTop--];
            }
            opStack[++opTop] = infix[i];
            lastWasOperator = 1;
        }
    }
    
    while (opTop >= 0) {
        postfix[j++] = opStack[opTop--];
    }
    postfix[j] = '\0';
    return postfix;
}

// Build syntax tree from postfix expression
TreeNode* buildSyntaxTree(char* postfix) {
    nodeTop = -1;
    
    for (int i = 0; postfix[i] != '\0'; i++) {
        if (postfix[i] == '~') {
            // Unary minus
            TreeNode* node = createNode('-', 1);
            node->right = nodeStack[nodeTop--];
            nodeStack[++nodeTop] = node;
        }
        else if (isOperator(postfix[i])) {
            // Binary operator
            TreeNode* node = createNode(postfix[i], 0);
            node->right = nodeStack[nodeTop--];
            node->left = nodeStack[nodeTop--];
            nodeStack[++nodeTop] = node;
        }
        else {
            // Operand
            TreeNode* node = createNode(postfix[i], 0);
            nodeStack[++nodeTop] = node;
        }
    }
    return nodeStack[nodeTop];
}

// Inorder traversal of syntax tree
void inorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    
    if (root->isUnary) {
        printf("(-");
        inorderTraversal(root->right);
        printf(")");
    } else if (isOperator(root->data)) {
        printf("(");
        inorderTraversal(root->left);
        printf("%c", root->data);
        inorderTraversal(root->right);
        printf(")");
    } else {
        printf("%c", root->data);
    }
}

// Generate quadruples from syntax tree
void generateQuadruples(TreeNode* root, char* result) {
    if (root == NULL) return;
    
    if (!isOperator(root->data)) {
        result[0] = root->data;
        result[1] = '\0';
        return;
    }
    
    if (root->isUnary) {
        // Unary operator
        char rightArg[10];
        generateQuadruples(root->right, rightArg);
        
        sprintf(result, "t%d", tempCount++);
        quads[quadCount].op = root->data;
        strcpy(quads[quadCount].arg1, rightArg);
        strcpy(quads[quadCount].arg2, "");
        strcpy(quads[quadCount].result, result);
        quadCount++;
    } else {
        // Binary operator
        char leftArg[10], rightArg[10];
        generateQuadruples(root->left, leftArg);
        generateQuadruples(root->right, rightArg);
        
        sprintf(result, "t%d", tempCount++);
        quads[quadCount].op = root->data;
        strcpy(quads[quadCount].arg1, leftArg);
        strcpy(quads[quadCount].arg2, rightArg);
        strcpy(quads[quadCount].result, result);
        quadCount++;
    }
}

// Count operators in subtree
int countOps(TreeNode* root) {
    if (root == NULL || !isOperator(root->data)) return 0;
    return 1 + countOps(root->left) + countOps(root->right);
}

// Generate triples from syntax tree
void generateTriples(TreeNode* root) {
    if (root == NULL || !isOperator(root->data)) return;
    
    int leftOps = countOps(root->left);
    
    generateTriples(root->left);
    generateTriples(root->right);
    
    triples[tripleCount].op = root->data;
    
    if (root->isUnary) {
        // Unary operator
        triples[tripleCount].arg1[0] = '\0';
        
        if (root->right && isOperator(root->right->data)) {
            sprintf(triples[tripleCount].arg2, "(%d)", tripleCount - 1);
        } else if (root->right) {
            triples[tripleCount].arg2[0] = root->right->data;
            triples[tripleCount].arg2[1] = '\0';
        }
    } else {
        // Binary operator - left argument
        if (root->left && isOperator(root->left->data)) {
            int leftOpsCount = countOps(root->left);
            sprintf(triples[tripleCount].arg1, "(%d)", tripleCount - leftOpsCount - countOps(root->right));
        } else if (root->left) {
            triples[tripleCount].arg1[0] = root->left->data;
            triples[tripleCount].arg1[1] = '\0';
        }
        
        // Binary operator - right argument
        if (root->right && isOperator(root->right->data)) {
            sprintf(triples[tripleCount].arg2, "(%d)", tripleCount - 1);
        } else if (root->right) {
            triples[tripleCount].arg2[0] = root->right->data;
            triples[tripleCount].arg2[1] = '\0';
        }
    }
    
    tripleCount++;
}

// Print quadruples
void printQuadruples() {
    printf("\n=== QUADRUPLES ===\n");
    printf("%-5s %-5s %-5s %-5s %-5s\n", "No.", "Op", "Arg1", "Arg2", "Result");
    printf("------------------------------------\n");
    for (int i = 0; i < quadCount; i++) {
        printf("%-5d %-5c %-5s %-5s %-5s\n", i, quads[i].op, 
               quads[i].arg1, 
               strlen(quads[i].arg2) > 0 ? quads[i].arg2 : "-", 
               quads[i].result);
    }
}

// Print triples
void printTriples() {
    printf("\n=== TRIPLES ===\n");
    printf("%-5s %-5s %-10s %-10s\n", "No.", "Op", "Arg1", "Arg2");
    printf("------------------------------------\n");
    for (int i = 0; i < tripleCount; i++) {
        printf("%-5d %-5c %-10s %-10s\n", i, triples[i].op, 
               strlen(triples[i].arg1) > 0 ? triples[i].arg1 : "-",
               triples[i].arg2);
    }
}

// Print indirect triples
void printIndirectTriples() {
    printf("\n=== INDIRECT TRIPLES ===\n");
    printf("Statement Table:\n");
    for (int i = 0; i < tripleCount; i++) {
        printf("%d -> (%d)\n", i, i);
    }
    printf("\nTriple Table:\n");
    printf("%-5s %-5s %-10s %-10s\n", "No.", "Op", "Arg1", "Arg2");
    printf("------------------------------------\n");
    for (int i = 0; i < tripleCount; i++) {
        printf("%-5d %-5c %-10s %-10s\n", i, triples[i].op, 
               strlen(triples[i].arg1) > 0 ? triples[i].arg1 : "-",
               triples[i].arg2);
    }
}

// Create DAG node
DAGNode* createDAGNode(char data, int id, int isUnary) {
    DAGNode* node = (DAGNode*)malloc(sizeof(DAGNode));
    node->data = data;
    node->left = node->right = NULL;
    node->id = id;
    node->isUnary = isUnary;
    return node;
}

// Find existing DAG node with same operation
DAGNode* findDAGNode(char op, DAGNode* left, DAGNode* right, int isUnary) {
    for (int i = 0; i < dagCount; i++) {
        if (dagNodes[i]->data == op && 
            dagNodes[i]->isUnary == isUnary &&
            dagNodes[i]->left == left && 
            dagNodes[i]->right == right) {
            return dagNodes[i];
        }
    }
    return NULL;
}

// Build DAG from postfix expression
DAGNode* buildDAG(char* postfix) {
    DAGNode* stack[MAX];
    int top = -1;
    
    for (int i = 0; postfix[i] != '\0'; i++) {
        if (postfix[i] == '~') {
            // Unary minus
            DAGNode* right = stack[top--];
            DAGNode* existing = findDAGNode('-', NULL, right, 1);
            
            if (existing) {
                stack[++top] = existing;
            } else {
                DAGNode* node = createDAGNode('-', dagCount, 1);
                node->right = right;
                dagNodes[dagCount++] = node;
                stack[++top] = node;
            }
        }
        else if (isOperator(postfix[i])) {
            DAGNode* right = stack[top--];
            DAGNode* left = stack[top--];
            
            DAGNode* existing = findDAGNode(postfix[i], left, right, 0);
            if (existing) {
                stack[++top] = existing;
            } else {
                DAGNode* node = createDAGNode(postfix[i], dagCount, 0);
                node->left = left;
                node->right = right;
                dagNodes[dagCount++] = node;
                stack[++top] = node;
            }
        } else {
            DAGNode* node = createDAGNode(postfix[i], dagCount, 0);
            dagNodes[dagCount++] = node;
            stack[++top] = node;
        }
    }
    return stack[top];
}

// Print tree structure (for syntax tree)
void printTree(TreeNode* root, char* prefix, int isRight) {
    if (root == NULL) return;
    
    printf("%s", prefix);
    printf("%s", isRight ? "└── " : "├── ");
    
    if (root->isUnary) {
        printf("(UNARY -)");
    } else {
        printf("%c", root->data);
    }
    printf("\n");
    
    char newPrefix[200];
    sprintf(newPrefix, "%s%s", prefix, isRight ? "    " : "│   ");
    
    if (root->isUnary) {
        printTree(root->right, newPrefix, 1);
    } else if (root->left || root->right) {
        if (root->left) printTree(root->left, newPrefix, 0);
        if (root->right) printTree(root->right, newPrefix, 1);
    }
}

// Print DAG as a proper graph with node list and edges
void printDAGGraph(DAGNode* root) {
    printf("\nNodes:\n");
    printf("%-5s %-10s %-10s\n", "ID", "Value", "Type");
    printf("--------------------------------\n");
    
    for (int i = 0; i < dagCount; i++) {
        printf("%-5d %-10c %-10s\n", 
               dagNodes[i]->id, 
               dagNodes[i]->data,
               dagNodes[i]->isUnary ? "Unary" : 
               (isOperator(dagNodes[i]->data) ? "Binary Op" : "Operand"));
    }
    
    printf("\nEdges:\n");
    printf("%-10s -> %-10s\n", "From", "To");
    printf("--------------------------------\n");
    
    for (int i = 0; i < dagCount; i++) {
        if (dagNodes[i]->left) {
            printf("Node %-5d -> Node %-5d (left)\n", 
                   dagNodes[i]->id, dagNodes[i]->left->id);
        }
        if (dagNodes[i]->right) {
            printf("Node %-5d -> Node %-5d (right)\n", 
                   dagNodes[i]->id, dagNodes[i]->right->id);
        }
    }
    
    printf("\nRoot: Node %d\n", root->id);
}

// Print DAG structure as tree visualization
void printDAGTree(DAGNode* root, char* prefix, int isRight) {
    if (root == NULL) return;
    
    printf("%s", prefix);
    printf("%s", isRight ? "└── " : "├── ");
    
    if (root->isUnary) {
        printf("[%d] UNARY-%c", root->id, root->data);
    } else {
        printf("[%d] %c", root->id, root->data);
    }
    printf("\n");
    
    char newPrefix[200];
    sprintf(newPrefix, "%s%s", prefix, isRight ? "    " : "│   ");
    
    if (root->isUnary) {
        printDAGTree(root->right, newPrefix, 1);
    } else if (root->left || root->right) {
        if (root->left) printDAGTree(root->left, newPrefix, 0);
        if (root->right) printDAGTree(root->right, newPrefix, 1);
    }
}

int main() {
    char infix[MAX], postfix[MAX];
    char result[10];
    
    printf("Enter an arithmetic expression (e.g., a+b*c or a+-(b+c)): ");
    fgets(infix, MAX, stdin);
    infix[strcspn(infix, "\n")] = '\0';
    
    // Convert to postfix
    strcpy(postfix, infixToPostfix(infix));
    printf("\nPostfix Expression: %s\n", postfix);
    printf("(Note: ~ represents unary minus)\n");
    
    // Build and display Syntax Tree
    TreeNode* syntaxTree = buildSyntaxTree(postfix);
    printf("\n=== SYNTAX TREE ===\n");
    printf("Inorder: ");
    inorderTraversal(syntaxTree);
    printf("\n\nTree Structure:\n");
    printTree(syntaxTree, "", 1);
    
    // Generate and display Quadruples
    tempCount = 0;
    generateQuadruples(syntaxTree, result);
    printQuadruples();
    
    // Generate and display Triples
    tripleCount = 0;
    generateTriples(syntaxTree);
    printTriples();
    
    // Display Indirect Triples
    printIndirectTriples();
    
    // Build and display DAG
    dagCount = 0;
    DAGNode* dag = buildDAG(postfix);
    printf("\n=== DAG (Directed Acyclic Graph) ===\n");
    printf("\nTree View:\n");
    printDAGTree(dag, "", 1);
    printDAGGraph(dag);
    
    return 0;
}

CODE OPTIMIZATION - TIME FUNC ONLY

#include <stdio.h>
#include <time.h>
#include <sys/time.h>

// Function to get time in microseconds
double get_time() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec * 1000000.0 + tv.tv_usec;
}

// ========== YOUR FUNCTION 1 (Original/Unoptimized) ==========
void function1() {
    // Put your first function code here
    int sum = 0;
    for (int i = 0; i < 10000000; i++) {
        sum = sum + i;
    }
}

// ========== YOUR FUNCTION 2 (Modified/Optimized) ==========
void function2() {
    // Put your second function code here
    long long sum = 0;
    for (int i = 0; i < 10000000; i += 4) {
        sum += i + (i+1) + (i+2) + (i+3);
    }
}

int main() {
    double start, end, time1, time2;
    
    printf("Testing Function Execution Times...\n\n");
    
    // Test Function 1
    start = get_time();
    function1();
    end = get_time();
    time1 = end - start;
    
    // Test Function 2
    start = get_time();
    function2();
    end = get_time();
    time2 = end - start;
    
    // Display Results
    printf("Function 1 Time: %.2f microseconds (%.4f ms)\n", time1, time1/1000.0);
    printf("Function 2 Time: %.2f microseconds (%.4f ms)\n", time2, time2/1000.0);
    printf("\n");
    printf("Time Difference: %.2f microseconds (%.4f ms)\n", 
           time1 - time2, (time1 - time2)/1000.0);
    
    if (time1 > time2) {
        printf("Function 2 is %.2fx FASTER\n", time1/time2);
        printf("Improvement: %.2f%%\n", ((time1-time2)/time1)*100);
    } else {
        printf("Function 1 is %.2fx FASTER\n", time2/time1);
        printf("Improvement: %.2f%%\n", ((time2-time1)/time2)*100);
    }
    
    return 0;
}


